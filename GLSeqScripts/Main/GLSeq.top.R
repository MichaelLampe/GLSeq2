#########################################################
# Great Lakes Seq package for low-level processing of RNA-Seq data
# Oleg Moskvin; info@scienceforever.com
# Sept 18, 2013
#########################################################
#
# This is the top-level executable script
#
#########################################################
#
# Usage: Rscript GLSeq.top.R (no)update (no)dataprep (no)alignment (no)counting (no)collect expID AttributeFilePath
#
#########################################################
#
# Starts counting the time
start.time <- proc.time()
#
args <- commandArgs(trailingOnly = TRUE)
#
# update attributes from DB? (otherwise, use values from GLSeg.R as is)
# values: "update", "noupdate" or the name of a particular file with run attributes (GLSeq.attr.XXX.R)
#
#
#### CURRENTLY NOT USED FOR ANYTHING
updateFromDb <- as.character(args[1])
#
#
#
# prepare data from fastq.gz files? (if not, the split and ready fastq files must be already in the dest.dir)
# values: "dataprep", "nodataprep"
dataPrepare <- as.character(args[2])
#
# Align data?
# values: "alignment", "noalignment"
alignment <- as.character(args[3])
#
# Count data?
# values: "nocounting","counting"
counting <- as.character(args[4])
#
# collect results?
# values: "collect", "nocollect"
resCollect <- as.character(args[5])
#
# experiment ID
# unique experiment ID used as a key to retrieve atributes from the database for the data processing
# Text addition to the output files (after library name)
# typically - unique ID of the experiment
# the ID of the run (text.add) generated by the script itself, will be this value concatenated with serial number (01...99)
expID <- as.character(args[6])
#
# protocol ID
# unique protocol ID used as a key to retrieve atributes from the "protocol" table od the DB
protID <- as.character(args[7])
#
# full path to the attribute file of this particular run
# this replaces the original reading of the attribute file from the GLSeq folder (may cause conflicts if more than 1 user want to use GLSeq at the same time)
attrPath <- as.character(args[8])
#
Condor <- as.logical(args[9])
#
# Naturally set to null, if the user would like they can activate
# this log type in the cattribute file by assigning it.
destDirTest <- NULL
#
#
source(attrPath)
# Little trick that allows us to run the top script from anywhere instead of having to be within the RScript folder
setwd(base.dir)
source("GLSeq.Util.R")
source("GLSeq.Top.Functions.R")
#
# Some little fixes to make sure that Condor works.
# Also assigns the nStreams to give the most parallel jobs
if(is.na(Condor)){
  Condor <- FALSE
}
if(Condor){
  nStreams <- 1000
  nStreamsDataPrep <- 1000
}
#
##################################################################################################
##################################################################################################
# Running Script Area
##################################################################################################
runAttempt <- formatC(1, width=2, flag="0")
runDate <-  paste(strsplit(date()," ")[[1]], collapse="_")
runDate <- gsub(":", "_", runDate)

###########
# Create general files and folders.
###########
# Checks the directories
dest.dir.base <- trailDirCheck(dest.dir.base)
base.dir <- trailDirCheck(base.dir)
text.add <- create.text.add(expID,runAttempt)

# Fixes any lack of final slash issues
dest.dir.base <- trailDirCheck(dest.dir.base)
base.dir <- trailDirCheck(base.dir)

# Create the destination directory
dest.dir <- create.dest.dir(dest.dir.base, text.add)
create.run.directory(dest.dir,Condor)
# Create destination directory for log/ stat files
destDirLog <- create.dest.dir.log(dest.dir,text.add)
create.log.directory(destDirLog,Condor)
#log.file <- instantiate.logs(dest.dir,text.add,destDirTest,Condor)

# Raw directory name with guaranteed trailing slash:
if (!is.null(raw.dir)) raw.dir <- trailDirCheck(raw.dir)
if (!is.null(readyData.dir)) readyData.dir <- trailDirCheck(readyData.dir)
if (!is.null(picardToolsPath)) picardToolsPath <- trailDirCheck(picardToolsPath)

if (alignment == "alignment" || counting == "counting"){
  #
  if ("HTSeq" %in% cAlgor){
    destDirHTSeqCount <- create.HtSeq.folder(dest.dir,text.add,Condor)
  }
  #
  if ("FeatureCounts" %in% cAlgor){
    destDirFeatureCountsCount <- create.FeatureCounts.folder(dest.dir,text.add,Condor)
  }
  #
  if ("RSEM" %in% cAlgor){
    destDirRSEMCount <- create.RSEM.folder(dest.dir,text.add,Condor)
  }
  if ("Cufflinks" %in% cAlgor){
    destDirCufflinksCount <- create.Cufflinks.folder(dest.dir, text.add,Condor)
  }
}

if (resCollect == "collect"){
  if (alignment == "alignment" || counting == "counting"){
    collectDir <- create.Collect.folder(dest.dir, text.add,Condor)
  } else{
    collectDir <- create.Collect.folder(previous.dir,text.add,Condor)
  }
}

copy.attribute.file.to.dest(attrPath,dest.dir,Condor)
create.run.logs(destDirLog,text.add)

###########
# Prepare raw data
###########
if (dataPrepare == "dataprep") {
  find.files.for.dataprep(raw.dir,unzipped,libList)
  relative.fqFiles <- run.data.prep(destDirLog,text.add,attrPath,dest.dir,base.dir,Condor)
}

# Construct alignment + counting comm stack
if (alignment == "alignment") {
  if (dataPrepare == "nodataprep") {

    if (is.null(libList)){
      copy.preprocessed.files.dir(readyData.dir,dest.dir,Condor)
      fqfiles.table <- convert.file.list.to.table.dir(paired.end,readyData.dir,NULL)
    } else {
      copy.preprocessed.files.list(libList,dest.dir,Condor)
      fqfiles.table <- convert.file.list.to.table.dir(paired.end,NULL,libList)
    }

  }
  if (dataPrepare == "dataprep"){
    fqfiles.table <- convert.file.list.to.table(paired.end,NULL,relative.fqFiles)

  }
  nStreams <- check.nStreams(fqfiles.table,nStreams)
  rangelist <- prepare.chunk.function(fqfiles.table,nStreams)
  comm.stack.pool <- start.alignment.process(base.dir,rangelist,nStreams,Condor)
}


if (alignment == "noalignment") {
  # If only counting, construct counting comm stack
  if (counting == "counting") {
    comm.stack.pool <- start.counting.process(countable.sams.dir,dest.dir,base.dir,Condor)
  }

  if (counting == "nocounting"){
    destDirFeatureCountsCount <- previous.run.FeatureCounts(previous.dir,previous.run.name)
    destDirHTSeqCount <- previous.run.HTSeq(previous.dir,previous.run.name)
    destDirRSEMCount <-previous.run.RSEM(previous.dir,previous.run.name)
  }
}

# Collect results.  We can't really source this, as that doesn't match our data state.
# We have to know what to collect before we have it to collect or we can just call the function
# At the time when it is ready with the correct variables by saving the current environment
if (resCollect == "collect"){
  data.file <- paste(dest.dir,"collect.run.status.RData",sep="")
  save.image(file=data.file)
  collect.command <- ""
  #
  #############################################################################################
  ###############################          HTSeq             #################################
  #############################################################################################
  if ("HTSeq" %in% cAlgor){
    collect.script <- paste(base.dir,"GLSeq.ResultsCollectHTSeq.R",sep="")
    collect.script.args <- paste(data.file)
    collect.command <- paste(collect.command,"Rscript",collect.script,collect.script.args,"&")
  }
  #
  #############################################################################################
  ###############################         Feature Counts      #################################
  #############################################################################################
  if ("FeatureCounts" %in% cAlgor){
    collect.script <- paste(base.dir,"GLSeq.ResultsCollectFeatureCounts.R",sep="")
    collect.script.args <- paste(data.file)
    collect.command <- paste(collect.command,"Rscript",collect.script,collect.script.args,"&")
  }
  #
  #############################################################################################
  ###############################            RSEM             #################################
  #############################################################################################
  if ("RSEM" %in% cAlgor){
    collect.script <- paste(base.dir,"GLSeq.ResultsCollectRSEM.R",sep="")
    collect.script.args <- paste(data.file)
    collect.command <- paste(collect.command,"Rscript",collect.script,collect.script.args,"&")
  }
  #
  #############################################################################################
  ###############################          Cufflinks         #################################
  #############################################################################################
  if ("Cufflinks" %in% cAlgor){
    collect.script <- paste(base.dir,"GLSeq.ResultsCollectCufflinks.R",sep="")
    collect.script.args <- paste(data.file)
    # Currently disabled
    #collect.command <- paste(collect.command,"Rscript",collect.script,collect.script.args,"&")
  }
  if (collect.script != ""){
    if (is.null(comm.stack.pool)){
      comm.stack.pool <- paste(collect.command)
    } else{
      comm.stack.pool <- paste(comm.stack.pool,"&&",paste("(",collect.command,")",sep=""))
    }
  }
} else{
  data.file <- paste(dest.dir,"ScriptEndStatus.RData",sep="")
  save.image(file=data.file)
}

if (!is.null(comm.stack.pool)){
  execute.comm.stack(comm.stack.pool,Condor)
}
# Creates a memory of a completed run so that the User Interface knows that this run has completed and should not allow any user to overwrite this run.
run.id.run <- paste(base.dir,paste(expID,"RData",sep="."),sep="")
save.image(file=run.id.run)