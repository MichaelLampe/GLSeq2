#########################################################
# Great Lakes Seq package for low-level processing of RNA-Seq data
# Oleg Moskvin; info@scienceforever.com 
# Sept 18, 2013 
#########################################################
# 
# This is the top-level executable script  
#
#########################################################
#
# Usage: Rscript GLSeq.top.R (no)update (no)dataprep (no)alignment (no)counting (no)collect expID AttributeFilePath
#
#########################################################
#
# Starts counting the time
start.time <- proc.time()
#
args <- commandArgs(trailingOnly = TRUE)
#
# update attributes from DB? (otherwise, use values from GLSeg.R as is)
# values: "update", "noupdate" or the name of a particular file with run attributes (GLSeq.attr.XXX.R)
#
#
#### CURRENTLY NOT USED FOR ANYTHING
updateFromDb <- as.character(args[1])
#
#
#
# prepare data from fastq.gz files? (if not, the split and ready fastq files must be already in the dest.dir)
# values: "dataprep", "nodataprep"
dataPrepare <- as.character(args[2])
#
# Align data?
# values: "alignment", "noalignment" 
alignment <- as.character(args[3])
# 
# Count data?
# values: "nocounting","counting"
counting <- as.character(args[4])
#
# collect results? 
# values: "collect", "nocollect" 
resCollect <- as.character(args[5])
#
# experiment ID
# unique experiment ID used as a key to retrieve atributes from the database for the data processing 
# Text addition to the output files (after library name)
# typically - unique ID of the experiment
# the ID of the run (text.add) generated by the script itself, will be this value concatenated with serial number (01...99) 
expID <- as.character(args[6])
#
# protocol ID
# unique protocol ID used as a key to retrieve atributes from the "protocol" table od the DB 
protID <- as.character(args[7])
#
# full path to the attribute file of this particular run 
# this replaces the original reading of the attribute file from the GLSeq folder (may cause conflicts if more than 1 user want to use GLSeq at the same time)
attrPath <- as.character(args[8])
#
#
# Naturally set to null, if the user would like they can activate
# this log type in the cattribute file by assigning it.
destDirTest <- NULL
#
#
source(attrPath)
# Little trick that allows us to run the top script from anywhere instead of having to be within the RScript folder
setwd(base.dir)
source("GLSeq.Util.R")
source("GLSeq.Top.Functions.R")

#
#
##################################################################################################
##################################################################################################
# Running Script Area
##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################
##################################################################################################
runAttempt <- formatC(1, width=2, flag="0")
runDate <-  paste(strsplit(date()," ")[[1]], collapse="_")
runDate <- gsub(":", "_", runDate)

###########
# Create general files and folders.
###########
# Checks the directories
dest.dir.base <- trailDirCheck(dest.dir.base)
base.dir <- trailDirCheck(base.dir)
text.add <- create.text.add(expID,runAttempt)

# Fixes any lack of final slash issues
dest.dir.base <- trailDirCheck(dest.dir.base) 
base.dir <- trailDirCheck(base.dir)

# Create the destination directory
dest.dir <- create.dest.dir(dest.dir.base, text.add)
create.run.directory(dest.dir)
# Create destination directory for log/ stat files
destDirLog <- create.dest.dir.log(dest.dir,text.add)
create.log.directory(destDirLog)
log.file <- instantiate.logs(dest.dir,text.add,destDirTest)

# Raw directory name with guaranteed trailing slash: 
if (!is.null(raw.dir)) raw.dir <- trailDirCheck(raw.dir)
if (!is.null(readyData.dir)) readyData.dir <- trailDirCheck(readyData.dir)
if (!is.null(picardToolsPath)) picardToolsPath <- trailDirCheck(picardToolsPath)

if (alignment == "alignment" || counting == "counting"){
  #
  if ("HTSeq" %in% cAlgor){
    destDirHTSeqCount <- create.HtSeq.folder(dest.dir,text.add,log.file)
  }
  #
  if ("FeatureCounts" %in% cAlgor){
    destDirFeatureCountsCount <- create.FeatureCounts.folder(dest.dir,text.add,log.file)
  }
  #
  if ("RSEM" %in% cAlgor){
    destDirRSEMCount <- create.RSEM.folder(dest.dir,text.add,log.file)
  }
  if ("Cufflinks" %in% cAlgor){
    destDirCufflinksCount <- create.Cufflinks.folder(dest.dir, text.add,log.file)
  }
}

if (resCollect == "collect"){
  if (alignment == "alignment" || counting == "counting"){
    collectDir <- create.Collect.folder(dest.dir, text.add,log.file)
  } else{
    collectDir <- create.oldRun.Collect.folder(previous.dir,text.add,log.file)
  }
}

copy.attribute.file.to.dest(attrPath,dest.dir,log.file=NULL)
create.run.logs(destDirLog,text.add)

###########
# Prepare raw data
###########
if (dataPrepare == "dataprep") {
  find.files.for.dataprep(raw.dir,unzipped,log.file)
  run.data.prep(destDirLog,text.add,attrPath,dest.dir)
}

# Construct alignment + counting comm stack
if (alignment == "alignment") {
  if (dataPrepare == "nodataprep") {
    copy.preprocessed.files(readyData.dir,dest.dir,log.file=NULL) 
  }
  fqfiles.table <- convert.file.list.to.table(paired.end,dest.dir)
  nStreams <- check.nStreams(fqfiles.table,nStreams)
  rangelist <- prepare.chunk.function(fqfiles.table,nStreams)
  comm.stack.pool <- start.alignment.process(base.dir,rangelist,nStreams,log.file)
}


if (alignment == "noalignment") {
  # If only counting, construct counting comm stack
  if (counting == "counting") {
    comm.stack.pool <- start.counting.process(countable.sams.dir,dest.dir,base.dir,log.file=NULL)
  }
  
  if (counting == "nocounting"){
    destDirFeatureCountsCount <- previous.run.FeatureCounts(previous.dir,previous.run.name)
    destDirHTSeqCount <- previous.run.HTSeq(previous.dir,previous.run.name)
    destDirRSEMCount <-previous.run.RSEM(previous.dir,previous.run.name)
  }
}

if (counting == "counting"){
  if ("RSEM" %in% cAlgor){
    comm.stack.pool <- RSEM.finish(comm.stack.pool,destDirRSEMCount,dest.dir)
  }
}
execute.comm.stack(comm.stack.pool,log.file)
add.to.logs(paste("The process took:",(proc.time()[3]-start.time[3]),"seconds to complete."),log.file)
stop("Program complete.")
##################################################################################################